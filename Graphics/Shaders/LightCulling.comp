#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct LightUniform {
    vec4 Position;  // xyz=pos, w=range
    vec4 Color;     // xyz=color, w=intensity
    vec4 Direction; // xyz=dir, w=type
    vec4 Params;    // x=inner, y=outer, z=shadow, w=padding
};

layout(std140, set = 0, binding = 0) uniform CameraBuffer {
    mat4 View;
    mat4 Projection;
    mat4 ViewProjection;
    vec3 CameraPosition;
    float Padding;
    vec2 ScreenSize;
    int DebugMode;
};

layout(std430, set = 0, binding = 1) readonly buffer LightDataBuffer {
    LightUniform Lights[];
};

layout(std140, set = 0, binding = 2) uniform LightParams {
    uint LightCount;
};

layout(set = 0, binding = 3, rg32ui) uniform writeonly uimage2D LightGrid;

layout(std430, set = 0, binding = 4) buffer LightIndexListBuffer {
    uint LightIndices[];
};

layout(std430, set = 0, binding = 5) buffer LightIndexCounter {
    uint Counter;
};

shared uint s_TileLightIndices[1024];
shared uint s_TileLightCount;

// Constants for Ray-Cone test
const float RC_EPSILON_T = 1e-5;
const float RC_EPSILON_GEOM = 1e-5;

bool TestRaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float radius) {
    vec3 oc = rayOrigin - spherePos;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius * radius;
    const float A_EPSILON = 1e-7;

    if (abs(a) < A_EPSILON) {
        if (c <= 0.0) return true;
        return false;
    }

    float discriminant = b * b - 4.0 * a * c;
    if (discriminant < 0.0) return false;

    float sqrtD = sqrt(discriminant);
    float inv2a = 1.0 / (2.0 * a);
    float tNear = (-b - sqrtD) * inv2a;
    float tFar  = (-b + sqrtD) * inv2a;

    if (tNear > tFar) {
        float temp = tNear;
        tNear = tFar;
        tFar = temp;
    }

    if (tFar < 0.0) return false;

    return true;
}

bool TestRayCone(vec3 rayOrigin, vec3 rayDir, vec3 coneApex, vec3 coneAxis, float cosConeAngle, float coneHeight) {
    coneHeight = max(coneHeight, RC_EPSILON_T);
    float robustCosConeAngle = clamp(cosConeAngle, RC_EPSILON_GEOM, 1.0 - RC_EPSILON_GEOM);
    float cos2Angle = robustCosConeAngle * robustCosConeAngle;

    // Check if ray origin is inside the cone
    vec3 originToApex = rayOrigin - coneApex;
    float originHeight = dot(originToApex, coneAxis);
    
    if (originHeight >= -RC_EPSILON_T && originHeight <= coneHeight + RC_EPSILON_T) {
        if (originHeight > RC_EPSILON_T) {
            float originDist = length(originToApex);
            float originRadialDistSq = max(0.0, originDist * originDist - originHeight * originHeight);
            
            float sinAngle = sqrt(max(0.0, 1.0 - cos2Angle));
            float expectedRadius = originHeight * sinAngle / robustCosConeAngle;
            
            // Check if inside radius (sqrt of squared dist vs radius)
            if (sqrt(originRadialDistSq) <= expectedRadius + RC_EPSILON_T) {
                return true;
            }
        } else {
            // Very close to apex
            return true;
        }
    }

    vec3 co = originToApex;
    float rayDirDotAxis = dot(rayDir, coneAxis);
    float coDotAxis = dot(co, coneAxis);

    float A = rayDirDotAxis * rayDirDotAxis - cos2Angle;
    float B = 2.0 * (rayDirDotAxis * coDotAxis - dot(rayDir, co) * cos2Angle);
    float C = coDotAxis * coDotAxis - dot(co, co) * cos2Angle;

    float t1 = -1.0;
    float t2 = -1.0;

    if (abs(A) < RC_EPSILON_GEOM) {
        if (abs(B) >= RC_EPSILON_GEOM) {
            float t = -C / B;
            if (t > RC_EPSILON_T) t1 = t;
        }
    } else {
        float discriminant = B * B - 4.0 * A * C;
        if (discriminant >= 0.0) {
            float sqrtDisc = sqrt(discriminant);
            float inv2A = 1.0 / (2.0 * A);
            t1 = (-B - sqrtDisc) * inv2A;
            t2 = (-B + sqrtDisc) * inv2A;
        }
    }

    // Check cone surface intersections
    if (t1 > RC_EPSILON_T) {
         vec3 hit = rayOrigin + rayDir * t1;
         float h = dot(hit - coneApex, coneAxis);
         if (h >= -RC_EPSILON_T && h <= coneHeight + RC_EPSILON_T) return true;
    }
    if (t2 > RC_EPSILON_T) {
         vec3 hit = rayOrigin + rayDir * t2;
         float h = dot(hit - coneApex, coneAxis);
         if (h >= -RC_EPSILON_T && h <= coneHeight + RC_EPSILON_T) return true;
    }

    // Check base cap intersection
    if (abs(rayDirDotAxis) > RC_EPSILON_GEOM) {
         float t_base = (coneHeight - coDotAxis) / rayDirDotAxis;
         if (t_base > RC_EPSILON_T) {
             vec3 baseHit = rayOrigin + rayDir * t_base;
             vec3 baseToApex = baseHit - coneApex;
             // Check if point is within base circle
             float baseDistSq = dot(baseToApex, baseToApex) - coneHeight * coneHeight; 
             
             float sinAngle = sqrt(max(0.0, 1.0 - cos2Angle));
             float baseRadius = coneHeight * sinAngle / robustCosConeAngle;
             
             if (baseDistSq <= baseRadius * baseRadius + RC_EPSILON_T) return true;
         }
    }

    return false;
}

void main() {
    if (gl_LocalInvocationIndex == 0) {
        s_TileLightCount = 0;
    }
    barrier();

    uint tileX = gl_WorkGroupID.x;
    uint tileY = gl_WorkGroupID.y;
    uint tileSize = 16;
    
    vec2 tileMin = vec2(tileX, tileY) * float(tileSize);
    vec2 tileMax = vec2(tileX + 1, tileY + 1) * float(tileSize);
    
    // Frustum Planes
    vec2 invScreenSize = 1.0 / ScreenSize;
    float minX = (tileMin.x * invScreenSize.x) * 2.0 - 1.0;
    float maxX = (tileMax.x * invScreenSize.x) * 2.0 - 1.0;
    float topY = 1.0 - (tileMin.y * invScreenSize.y) * 2.0;
    float bottomY = 1.0 - (tileMax.y * invScreenSize.y) * 2.0;
    
    mat4 invProj = inverse(Projection);
    vec4 vTL = invProj * vec4(minX, topY, 1.0, 1.0); vTL /= vTL.w;
    vec4 vTR = invProj * vec4(maxX, topY, 1.0, 1.0); vTR /= vTR.w;
    vec4 vBL = invProj * vec4(minX, bottomY, 1.0, 1.0); vBL /= vBL.w;
    vec4 vBR = invProj * vec4(maxX, bottomY, 1.0, 1.0); vBR /= vBR.w;
    
    // Precompute rays for this tile
    vec3 dirTL = normalize(vTL.xyz);
    vec3 dirTR = normalize(vTR.xyz);
    vec3 dirBL = normalize(vBL.xyz);
    vec3 dirBR = normalize(vBR.xyz);
    vec3 dirC  = normalize(dirTL + dirBR); // Approx center

    vec3 rayOrigin = vec3(0.0);

    uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
    uint passCount = (LightCount + threadCount - 1) / threadCount;

    for (uint i = 0; i < passCount; i++) {
        uint lightIdx = i * threadCount + gl_LocalInvocationIndex;
        
        if (lightIdx < LightCount) {
            LightUniform light = Lights[lightIdx];
            vec4 viewPos4 = View * vec4(light.Position.xyz, 1.0);
            vec3 viewPos = viewPos4.xyz;
            bool visible = false;
            
            int type = int(light.Direction.w);

            if (type == 1) { // Directional
                visible = true;
            } 
            else if (type == 0) { // Point (Ray Sphere Test)
                float range = light.Position.w;
                vec3 spherePos = viewPos;
                
                if (TestRaySphere(rayOrigin, dirTL, spherePos, range) ||
                    TestRaySphere(rayOrigin, dirTR, spherePos, range) ||
                    TestRaySphere(rayOrigin, dirBL, spherePos, range) ||
                    TestRaySphere(rayOrigin, dirBR, spherePos, range) ||
                    TestRaySphere(rayOrigin, dirC, spherePos, range)) {
                    visible = true;
                }
            }
            else if (type == 2) { // Spot
                float range = light.Position.w;
                float outerAngle = light.Params.y;
                float cosAngle = cos(outerAngle);
                
                vec3 coneApex = viewPos;
                vec3 coneAxis = normalize(mat3(View) * light.Direction.xyz);
                
                // Better cone culling: Test if sphere enclosing the cone intersects the frustum rays
                // For a spot light, the sphere radius that covers the cone is approximately the range.
                // However, the sphere center is shifted from apex along the axis.
                float sphereRadius = range / (2.0 * cosAngle);
                if (outerAngle > 1.5) sphereRadius = range; // Handle very wide angles
                vec3 sphereCenter = coneApex + coneAxis * (range * 0.5);

                if (TestRaySphere(rayOrigin, dirTL, sphereCenter, sphereRadius) ||
                    TestRaySphere(rayOrigin, dirTR, sphereCenter, sphereRadius) ||
                    TestRaySphere(rayOrigin, dirBL, sphereCenter, sphereRadius) ||
                    TestRaySphere(rayOrigin, dirBR, sphereCenter, sphereRadius) ||
                    TestRaySphere(rayOrigin, dirC, sphereCenter, sphereRadius)) {
                    visible = true;
                }
            }
            
            if (visible) {
                uint index = atomicAdd(s_TileLightCount, 1);
                if (index < 1024) {
                    s_TileLightIndices[index] = lightIdx;
                }
            }
        }
    }
    
    barrier();
    
    if (gl_LocalInvocationIndex == 0) {
        uint count = s_TileLightCount;
        uint offset = atomicAdd(Counter, count);
        imageStore(LightGrid, ivec2(tileX, tileY), uvec4(offset, count, 0, 0));
        for (uint i = 0; i < count; i++) {
            LightIndices[offset + i] = s_TileLightIndices[i];
        }
    }
}
