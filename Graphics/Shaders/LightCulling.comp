#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct LightUniform {
    vec4 Position;  // xyz=pos, w=range
    vec4 Color;     // xyz=color, w=intensity
    vec4 Direction; // xyz=dir, w=type
    vec4 Params;    // x=inner, y=outer, z=shadow, w=padding
};

layout(std140, set = 0, binding = 0) uniform CameraBuffer {
    mat4 View;
    mat4 Projection;
    mat4 ViewProjection;
    vec3 CameraPosition;
    float Padding;
    vec2 ScreenSize;
    int DebugMode;
};

layout(std430, set = 0, binding = 1) readonly buffer LightDataBuffer {
    LightUniform Lights[];
};

layout(std140, set = 0, binding = 2) uniform LightParams {
    uint LightCount;
};

layout(set = 0, binding = 3, rg32ui) uniform writeonly uimage2D LightGrid;

layout(std430, set = 0, binding = 4) buffer LightIndexListBuffer {
    uint LightIndices[];
};

layout(std430, set = 0, binding = 5) buffer LightIndexCounter {
    uint Counter;
};

layout(set = 0, binding = 6) uniform texture2D HiZMap;
layout(set = 0, binding = 7) uniform sampler HiZSampler;

shared uint s_TileLightIndices[1024];
shared uint s_TileLightCount;

const float MAX_DIST = 1e20;
const float RC_EPSILON_T = 1e-5;
const float RC_EPSILON_GEOM = 1e-5;

float IntersectRaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float radius) {
    vec3 oc = rayOrigin - spherePos;
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius * radius;

    if (c <= 0.0) return 0.0; // Inside

    float discriminant = b * b - 4.0 * c;
    if (discriminant < 0.0) return MAX_DIST;

    float sqrtD = sqrt(discriminant);
    float tNear = (-b - sqrtD) * 0.5;
    float tFar  = (-b + sqrtD) * 0.5;

    if (tFar < 0.0) return MAX_DIST;
    return tNear > 0.0 ? tNear : tFar;
}

float IntersectRayCone(vec3 rayOrigin, vec3 rayDir, vec3 coneApex, vec3 coneAxis, float cosConeAngle, float coneHeight) {
    float robustCosConeAngle = clamp(cosConeAngle, RC_EPSILON_GEOM, 1.0 - RC_EPSILON_GEOM);
    float cos2Angle = robustCosConeAngle * robustCosConeAngle;

    vec3 originToApex = rayOrigin - coneApex;
    float originHeight = dot(originToApex, coneAxis);
    if (originHeight >= -RC_EPSILON_T && originHeight <= coneHeight + RC_EPSILON_T) {
        float originDistSq = dot(originToApex, originToApex);
        float radialDistSq = max(0.0, originDistSq - originHeight * originHeight);
        float expectedRadius = originHeight * sqrt(max(0.0, 1.0 - cos2Angle)) / robustCosConeAngle;
        if (sqrt(radialDistSq) <= expectedRadius + RC_EPSILON_T) return 0.0;
    }

    float rayDirDotAxis = dot(rayDir, coneAxis);
    float coDotAxis = dot(originToApex, coneAxis);
    float A = rayDirDotAxis * rayDirDotAxis - cos2Angle;
    float B = 2.0 * (rayDirDotAxis * coDotAxis - dot(rayDir, originToApex) * cos2Angle);
    float C = coDotAxis * coDotAxis - dot(originToApex, originToApex) * cos2Angle;

    float minT = MAX_DIST;
    float discriminant = B * B - 4.0 * A * C;
    if (discriminant >= 0.0) {
        float sqrtDisc = sqrt(discriminant);
        float t1 = (-B - sqrtDisc) / (2.0 * A);
        float t2 = (-B + sqrtDisc) / (2.0 * A);
        if (t1 > RC_EPSILON_T) {
            float h = dot(rayOrigin + rayDir * t1 - coneApex, coneAxis);
            if (h >= -RC_EPSILON_T && h <= coneHeight + RC_EPSILON_T) minT = min(minT, t1);
        }
        if (t2 > RC_EPSILON_T) {
            float h = dot(rayOrigin + rayDir * t2 - coneApex, coneAxis);
            if (h >= -RC_EPSILON_T && h <= coneHeight + RC_EPSILON_T) minT = min(minT, t2);
        }
    }

    if (abs(rayDirDotAxis) > RC_EPSILON_GEOM) {
        float t_base = (coneHeight - coDotAxis) / rayDirDotAxis;
        if (t_base > RC_EPSILON_T) {
            vec3 baseHit = rayOrigin + rayDir * t_base;
            vec3 baseToApex = baseHit - coneApex;
            float baseDistSq = dot(baseToApex, baseToApex) - coneHeight * coneHeight;
            float baseRadius = coneHeight * sqrt(max(0.0, 1.0 - cos2Angle)) / robustCosConeAngle;
            if (baseDistSq <= baseRadius * baseRadius + RC_EPSILON_T) minT = min(minT, t_base);
        }
    }
    return minT;
}

void main() {
    if (gl_LocalInvocationIndex == 0) s_TileLightCount = 0;
    barrier();

    uint tileX = gl_WorkGroupID.x;
    uint tileY = gl_WorkGroupID.y;
    vec2 invScreenSize = 1.0 / ScreenSize;
    
    vec2 tileMin = vec2(tileX, tileY) * 16.0;
    vec2 tileMax = vec2(tileX + 1, tileY + 1) * 16.0;
    
    // GL Style NDC (Top=1.0)
    float minX = (tileMin.x * invScreenSize.x) * 2.0 - 1.0;
    float maxX = (tileMax.x * invScreenSize.x) * 2.0 - 1.0;
    float topY = 1.0 - (tileMin.y * invScreenSize.y) * 2.0;
    float bottomY = 1.0 - (tileMax.y * invScreenSize.y) * 2.0;
    
    mat4 invProj = inverse(Projection);
    vec4 vTL = invProj * vec4(minX, topY, 1.0, 1.0); vTL /= vTL.w;
    vec4 vTR = invProj * vec4(maxX, topY, 1.0, 1.0); vTR /= vTR.w;
    vec4 vBL = invProj * vec4(minX, bottomY, 1.0, 1.0); vBL /= vBL.w;
    vec4 vBR = invProj * vec4(maxX, bottomY, 1.0, 1.0); vBR /= vBR.w;
    
    vec3 rays[5] = vec3[](normalize(vTL.xyz), normalize(vTR.xyz), normalize(vBL.xyz), normalize(vBR.xyz), normalize(vTL.xyz + vBR.xyz));
    vec2 tileUV = (vec2(tileX, tileY) + 0.5) * 16.0 * invScreenSize;
    
    // Flip Y for HiZ sampling to match the GL-style rays (if Proj is Vulkan Y-down, rays are flipped V)
    float tileMaxDepth = textureLod(sampler2D(HiZMap, HiZSampler), vec2(tileUV.x, 1.0 - tileUV.y), 4.0).r;

    uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
    uint passCount = (LightCount + threadCount - 1) / threadCount;

    for (uint i = 0; i < passCount; i++) {
        uint lightIdx = i * threadCount + gl_LocalInvocationIndex;
        if (lightIdx < LightCount) {
            LightUniform light = Lights[lightIdx];
            int type = int(light.Direction.w);
            bool visible = false;

            if (type == 1) {
                visible = true;
            } else {
                vec3 viewPos = (View * vec4(light.Position.xyz, 1.0)).xyz;
                float range = light.Position.w;
                vec3 coneAxis = normalize(mat3(View) * light.Direction.xyz);
                float cosAngle = cos(light.Params.y);

                bool intersects = false;
                for (int r = 0; r < 5; r++) {
                    float t = (type == 0) ? IntersectRaySphere(vec3(0), rays[r], viewPos, range) : 
                              IntersectRayCone(vec3(0), rays[r], viewPos, coneAxis, cosAngle, range);
                    if (t < 1e19) { 
                        intersects = true; 
                        break; 
                    }
                }
                
                if (intersects) {
                    float closestZ = viewPos.z + range;
                    vec4 clip = Projection * vec4(0.0, 0.0, closestZ, 1.0);
                    
                    if (clip.w <= 0.0) visible = true;
                    else {
                        float d = clip.z / clip.w;
                        visible = (d <= tileMaxDepth);
                    }
                } else {
                    visible = false;
                }
            }

            if (visible) {
                uint index = atomicAdd(s_TileLightCount, 1);
                if (index < 1024) s_TileLightIndices[index] = lightIdx;
            }
        }
    }
    barrier();
    if (gl_LocalInvocationIndex == 0) {
        uint count = s_TileLightCount;
        uint offset = atomicAdd(Counter, count);
        imageStore(LightGrid, ivec2(tileX, tileY), uvec4(offset, count, 0, 0));
        for (uint i = 0; i < count; i++) LightIndices[offset + i] = s_TileLightIndices[i];
    }
}